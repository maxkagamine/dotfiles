#!/bin/bash
#
# Copyright (c) Max Kagamine
# Licensed under the Apache License, Version 2.0
#
set -eo pipefail

# shellcheck source=mods/bash/.local/lib/common.sh
. ~/.local/lib/common.sh

if [[ $# == 0 || $1 =~ ^(--help|-h)$ ]]; then
  cat >&2 <<'EOF'
Usage: mkv-batch [<path...>] <mkvmerge opts>

Runs mkvmerge on each file, placing output in muxed/. Arguments up until one
beginning with a dash are interpreted as input files; all others are passed to
mkvmerge.

Directories are expanded to contained *.mkv files (non-recursive). If no paths
are given, the current directory is used.

Common options:

  -a, --audio-tracks [!]TID1,TID2,...     \
  -d, --video-tracks [!]TID1,TID2,...      | Can use lang codes instead.
  -s, --subtitle-tracks [!]TID1,TID2,...  /  Remember to quote/escape the '!'
  --track-order 0:TID1,0:TID2,...
  --default-track-flag TID[:0]
EOF
  printf '\nSee autocomplete suggestions and \e[34m\e]8;;https://mkvtoolnix.download/doc/mkvmerge.html\e\\mkvmerge manual\e]8;;\e\\\e[m.\n' >&2
  exit 1
fi

paths=()
while [[ $# != 0 && $1 != -* ]]; do
  paths+=("$1")
  shift
done

expand_directories \
  --glob '*.mkv' --var paths --default . --required -- "${paths[@]}"

opts=("$@")

if (( ${#opts[@]} == 0 )) && [[ ! $CLEANING ]]; then
  throw 'no mkvmerge opts given'
fi

mkdir -p muxed

for f in "${paths[@]}"; do
  # Remove crc from remuxed file (could update but it's pretty useless anyway)
  filename=$(basename "$f")
  output="muxed/$(perl -pe 's/ ?\[[a-f0-9]{8}\](?=\.mkv$)//i' <<<"$filename")"

  mkvmerge "${opts[@]}" "$f" -o "$output"
done

mkv-batch-verify
