#!/bin/bash
#
# Copyright (c) Max Kagamine
# Licensed under the Apache License, Version 2.0
#
set -eo pipefail

# shellcheck source=mods/bash/.local/lib/common.sh
. ~/.local/lib/common.sh

help() {
  cat >&2 <<'EOF'
Usage: mkv-extract-fonts [-n] [<path...>]

Extracts all unique fonts (by filename) from the given mkvs. Fonts are
extracted to the current directory.

Directories are expanded to contained *.mkv files (non-recursive). If no paths
are given, the current directory is used.

Options:

  -n, --dry-run    Dry run.
EOF
  exit 1
}

dry_run=

parse_args \
  -n,--dry-run 'dry_run=1' \
  -h,--help \
  -- "$@"

expand_directories \
  --glob '*.mkv' --var paths --default . --required -- "${REST[@]}"

list_fonts() { # <path>
  mkvmerge -J "$1" | jq -r '
    if .tracks | type != "array" then
      "\"\(.file_name)\" is not an mkv\n" | halt_error
    else
      .attachments[] | select(
        (.content_type | startswith("font/")) or
        .content_type == "application/x-truetype-font" or
        .content_type == "application/x-font-ttf" or
        .content_type == "application/vnd.ms-opentype" or
        .content_type == "application/font-sfnt" or
        .content_type == "application/font-woff" or
        (.file_name | test("\\.(ttf|otf|ttc|woff2?)$"; "i"))
      ) | (
        (.id | tostring) + ":" + .file_name
      )
    end
  '
}

for path in "${paths[@]}"; do
  echo "$path"

  fonts=()
  has_fonts=

  list=$(list_fonts "$path")

  while read -r line; do
    has_fonts=1
    filename=$(cut -f2 -d: <<<"$line")
    if [[ -f $filename ]]; then
      printf '  \e[36mAlready extracted\e[m %s\n' "$filename"
    else
      printf '  \e[32mExtracting\e[m %s\n' "$filename"
      fonts+=("$line")
    fi
  done <<<"$list"

  if [[ ! $has_fonts ]]; then
    printf '  No fonts\n'
    continue
  elif (( ${#fonts[@]} == 0 )) || [[ $dry_run ]]; then
    continue
  fi

  mkvextract "$path" attachments "${fonts[@]}" >/dev/null
done
