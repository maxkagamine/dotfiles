#!/bin/bash
#
# Copyright (c) Max Kagamine
# Licensed under the Apache License, Version 2.0
#
set -eo pipefail

# shellcheck source=mods/bash/.local/lib/common.sh
. ~/.local/lib/common.sh

help() {
  cat >&2 <<'EOF'
Usage: mkv-extract-subs [-l <languages>] [-n] [<path...>]

Extracts all subtitles from the given mkvs.

Directories are expanded to contained *.mkv files (non-recursive). If no paths
are given, the current directory is used.

Options:

  -l, --lang <languages>    Comma-separated list of three-letter language codes
                            to extract. Example: -l eng,und

  -n, --dry-run             Dry run.
EOF
  exit 1
}

languages=()
dry_run=

parse_args \
  -l,--lang 'IFS=, read -r -a languages <<<"{}"' \
  -n,--dry-run 'dry_run=1' \
  -h,--help \
  -- "$@"

expand_directories \
  --glob '*.mkv' --var paths --default . --required -- "${REST[@]}"

list_subtitle_tracks() { # <path>
  mkvmerge -J "$1" | jq -r '
    if .tracks | type != "array" then
      "\"\(.file_name)\" is not an mkv\n" | halt_error
    else
      .tracks[] | select(.type == "subtitles") | (
        (.id | tostring) + "\t" +
        .codec + "\t" +
        .properties.language + "\t" +
        .properties.track_name
      )
    end
  '
}

get_extension() { # <codec>
  case $1 in
    'SubStationAlpha') echo '.ass' ;;
    'SubRip/SRT') echo '.srt' ;;
    'HDMV PGS') echo '.sup' ;;
  esac
}

for path in "${paths[@]}"; do
  echo "$path"

  dir=$(dirname "$path")
  basename=$(basename "$path" .mkv)
  subs=()
  has_subs=

  list=$(list_subtitle_tracks "$path")

  while read -r line; do
    has_subs=1

    track_id=$(cut -f1 <<<"$line")
    track_codec=$(cut -f2 <<<"$line")
    track_language=$(cut -f3 <<<"$line")
    track_name=$(cut -f4 <<<"$line")

    formatted_name="track $track_id - $track_language"
    if [[ $track_name ]]; then
      formatted_name+=" - $track_name"
    fi

    skip=
    if (( ${#languages[@]} > 0 )); then
      skip=1
      for lang in "${languages[@]}"; do
        if [[ $track_language == "$lang" ]]; then
          skip=
          break
        fi
      done
    fi

    if [[ $skip ]]; then
      printf '  \e[36mSkipping\e[m %s\n' "$formatted_name"
    else
      printf '  \e[32mExtracting\e[m %s\n' "$formatted_name"
      filename="$basename - $(sanitize-filename -- "$formatted_name")"
      filename+=$(get_extension "$track_codec")
      subs+=("$track_id:$dir/$filename")
    fi
  done <<<"$list"

  if [[ ! $has_subs ]]; then
    printf '  No subtitles\n'
    continue
  elif (( ${#subs[@]} == 0 )) || [[ $dry_run ]]; then
    continue
  fi

  mkvextract "$path" tracks "${subs[@]}" > /dev/null
done
